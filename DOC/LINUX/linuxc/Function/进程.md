# 进程

## 定义

```
linux内核启动0进程，0进程启动1进程和2进程（有些linux只启动1进程），1，2再启动其他所有进程

进程常见的状态：
S  休眠状态
s   有子进程
o   可运行状态
R   运行状态
z    僵尸进程（已结束但资源未回收）
1）父进程启动子进程，父子进程同时运行
2）如果子进程先结束，子进程给父进程发信号，由父进程负责回收子进程的相关资源
3）如果父进程先结束，自进程会把init（进程1）作为新的父进程
4）如果子进程先结束，同时发出的信号父进程未收到或子进程未发信号，子进程就变成僵尸进程

linux下一个进程在内存里有三部分：数据段，堆栈段，代码段
堆栈段存放的是子进程的返回地址，子进程的参数以及子进程的局部变量，而数据段则存放程序的全局变量，常数以及动态数据分配的空间，系统如果同时运行多个相同的程序，他们之间就不可能使用同一个堆栈段和数据段。
```

## PID

```
<unistd.h>
进程id（PID），非负整型，是唯一的，但也可以延迟重用
getpid()         取当前进程id
getppid()        取当前进程的父进程id
getuid()/geteuid()   取当前有效用户的id
```

## fork

```
<unistd.h>
pid_t   fork()     失败返回-1

fork通过复制自身（父进程）创建子进程。（复制代码区之外的内存区域，但和父进程共享代码区）fork之前的代码，父进程执行一次，fork之后的代码父子进程分别执行一次
fork自身会有两次返回，在父进程返回子进程id，在子进程返回0.
fork之后，父子进程同时运行，谁先运行不确定，子进程和父进程（虚拟内存地址相同），映射的物理内存不同
文件操作时，复制文件描述符，不复制文件表，所以父子进程相当于共用文件指针，不会相互覆盖
fork函数执行后，系统就为新的进程准备数据段，堆栈段和代码段，首先让新的进程和旧的进程使用同一个代码段，因为他们的程序还是相同的，对于数据段和堆栈段，系统复制一份给新的进程，但实际上数据已经分开，相互之间不再有影响，不再共享任何数据。fork复制两个段实际上是逻辑上的，并非物理上的复制，实际执行fork时，物理空间上两个进程的数据段和代码段都还是共享的，当有一个进程写了某个数据时，这是两个进程之间的数据才有了区别，系统就将有区别的页从物理上分开。

父进程结束，子进程不结束。
pid_t  pid=fork();
if(pid==0)//子进程pid为0
{
.......子进程执行的代码
       exit(0);
}
.........
........父进程执行的代码
```

## vfork

```
<unistd.h>
pid_t   vfork()     失败返回-1
vfork不复制父进程任何内存空间，创建的子进程占用父进程的内存空间运行，父进程在此时被阻塞。vfork和exec系列函数结合使用才有意义。vfork负责创建子进程，exec系列函数负责提供新的程序被执行。未使用exec系列函数则行为不确定。
一个进程一旦调用exec系列函数，它本身就终止了，系统把代码段替换成新的程序代码，废弃原来的数据段和代码段，并为新程序分配新的数据段和代码段，唯一留下的就是进程号。对系统而言，还是同一个进程，不过已经是另一个程序了。

exec系列函数（6种）不是新建一个进程，而是修改进程。用新的程序替换旧的，不改变pid（占用父进程的空间运行）
execl(“exe全路径”，“命令”，“选项”，“参数”,NULL）;
execlp 包含系统路径
execle 包含环境表
execl("/bin/ls","ls","-l","/home",NULL);//详细显示home目录下所有文件
execlp("ls","ls","-l","/home",NULL);


用于打开其他程序，父进程结束，子进程也结束。
pid_t pid = vfork();
if(pid == 0)//子进程pid为0
{
子进程执行的代码打开a这个程序
        execl("/home/jyl/a",0);
 }
cout<<"baseRun"<<endl;
while(1){}
........父进程执行的代码
```

## 终止进程

```
进程终止的正常情况：
1）main函数中执行return
2）调用exit函数
3）调用.exit或者_Exit
4）进程的最后一个线程执行了返回语句
5）进程的最后一个线程调用pthread_exit函数

异常终止：
1）调用abort，产生SIGABRT信号
2）进程接收到某些信号
3）最后一个线程对“取消”请求做出响应

<unistd.h> 
void  _exit(int status);
<stdlib.h>
void _Exit(int  status);
status:-1  非正常     0正常
<stdlib.h>
void  exit(int status);
  status:  -1非正常， 0正常
<stdlib.h>
void exit(int  status);
在退出之前会执行被on_exit()和atexit()注册的函数
atexit(函数指针)  注册放在exit之前
```

## 进程等待

```
<sys/wait.h>
pid_t  wait(int *status)      status作为返回值类型
成功返回子进程id，失败返回-1
用于父进程等待子进程的结束，等待任意一个子进程结束都会返回
返回结束子进程的状态和退出码
exit（100），则返回的退出码为100
wait（）可以回收僵尸子进程
宏函数：
WIFEXITED(status)可以判断是否正常结束
  wait if exit end
WEXITSTATUS(status)可以得到退出码
   （0到255有效）
exp：
pid_t  pid=fork();
if(pid==0){.........exit(100);}
int  status;
int  pid2=wait(&status);
等待子进程结束后执行下面的代码
if(WIFEXITED(status))
   printf(“%d\n”,WEXITSTATUS(status));

pid_t  waitpid(pid_t  pid, int  *status,  int options)
pid: -1  等待任意一个子进程结束
   >0   等待指定子进程结束
   <-1   取绝对值，绝对值代表一个进程组，等待这个进程组中任
         意一个子进程结束
   0    等待任意和父进程同一个进程组的子进程结束
options： WNOHANG   没有子进程结束，立即返回0
            wait no hang
      0  一直等待子进程结束
```
