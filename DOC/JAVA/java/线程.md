# 线程

## Thread子类

```
new Thread(){
    @Override
    public void run() {
    }
}.start();
```

```
class T extends Thread
{
   public void run(){}
}
//创建的线程默认是前台线程，即主线程结束后，线程未运行完也不会结束。
new T().start();

//在start前调用函数setDaemon可以让线程变成后台线程，当主线程运行结束后也停止。  
Thread th = new Thread(new T());
th.setDaemon(false);
th.start();
```

## Runnable接口

Thread(实现runnable的对象)  
Thread(实现runnable的对象，窗口名)


```
new Thread(new Runnable() {
    public void run(){ }
    }
).start();
```

```
class T implements Runnable {
    public void run(){ }
}
new Thread(new T()).start();

可以在Thread类中传入同一个对象，让多个线程共享同一个对象的内容。
class T implements Runnable {
  int count = 10;
  public void run() {
    while (count > 0) {
       Thread t = Thread.currentThread();//获取运行该语句的线程
       System.out.println(t.getName() + " count:" + count--);
    }
  }
}

T t = new T();
new Thread(t,"window1").start();
new Thread(t,"window2").start();
```

## 线程休眠

try
{
   Thread.sleep(2000);//当前线程休眠2S
}catch(InterruptedException e){}

## 线程优先级  

可以设置某个线程的优先级，作为提高程序效率的一种手段。  
th.setPriority(Thread.MAX_PRIORITY);  

## 线程让步  

当某个线程执行到yield函数时，转换成就绪状态，只有与当前线程优先级相同或者更高的才能获得执行机会。
Thread.yield();

## 线程插队

当某个线程中调用其他线程的join方法后，调用的线程被阻塞，直到被调用的线程结束后它才会执行。
th.join();

## 线程同步

多个线程操作同一对象，在该对象类的同步代码块或同步方法中操作相同资源，可以进行互斥。
  
第一个线程进入synchronized(lock)后占用了锁，第二个线程到synchronized(lock)时阻塞，直到第一个线程结束synchronized块内语句或者其他激活条件时第二个线程才执行synchronized(lock)后一句

```
同步代码块：
static Object lock = new Object();
public void run()
{
     synchronized(lock){ 同步块    }
}

同步方法：
同步方法的锁就是this对象，相当于进入函数后进入synchronized(this)语句块

synchronized void fun(){}
```

## 多线程通信

lock.wait() 使当前线程放弃同步锁lock，并进入等待，直到其他线程进入此同步锁，并调用notify或者notifyAll方法唤醒该线程为止。
notify唤醒此同步锁上等待的第一个调用wait方法的线程。
notify和wait需要使用锁对象调用，且调用位置在该锁对象由Syncoronized触发的代码块内。  

```
线程1，2公用Stack对象，1线程调用push()，2线程调用pop()。两个线程依靠互斥对象和notiy、wait方法交替执行
Stack stack = new Stack();
new Thread(new Th1(stack)).start();
new Thread(new Th2(stack)).start();

class Stack {
//可以不使用lock对象，直接把push和pop定义成synchronized方法，则两个方法使用进入时使用的是this作为锁
static Object lock = new Object();
     void push() throws InterruptedException {
    	 synchronized(lock)
    	 {
		int i = 0;
		while (true) {
			System.out.println("push" + i++);
			Thread.sleep(1000);
				
			if (i == 5) {
				i = 0;
				lock.notify();
				lock.wait();
			}
	       }
       }
}

void pop() throws InterruptedException {
		synchronized (lock) {
			int i = 0;
			while (true) {
				System.out.println("pop...." + i++);
				Thread.sleep(1000);
				
				if (i == 5) {
					i = 0;
					 lock.notify();
					 lock.wait();
				}
			}
		}
	}
}
```