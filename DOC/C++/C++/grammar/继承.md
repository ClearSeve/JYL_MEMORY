# 继承

## 定义

```
B继承自A，则B中有A的一切，而且对A进行了拓展。所以B可以强制类型转换成A，而A类的指针可以指向B，反之却不可以。
1）组合继承：在子类中定义一个基类的对象作为成员(不能实现多态)，不可以在B的初始化参数列表调用A的构造：
   class  B{A  a;...........};
2）class  B:public  A{.......};
   或者protect，private  
   可实现多态

在类中定义并实现另一个类时：
class  A{class B{};};
A、B不能直接互访成员，A相当于B的类外全局区
```

## 权限

```
public：可被任意实体访问到
protected：只允许本类成员及子类访问
private：只允许本类成员访问
1）public公有继承：public----------->public
                  子类内和外都可以访问
                  protected------------->protected
                  子类可访问（子类的子类可访问）类外不能访问
                  private------------->无权
                  子类内外都不可访问
2）protected保护继承：public、protected------------>protected
                     private------------->无权
3）private私有继承：public、protected---------->private
                   子类可访问（子类的子类不可访问），类外不可
                   访问到
                   private-------------->无权
子类无权访问时，如果在基类中将子类定义为友元类，则可访问。
或者在基类提供公有的接口让子类可以通过接口访问到
子类继承基类后，基类相当于子类的一个成员，等同于把基类中的成员写在子类中

子类中没有和基类相同名的数据时，可以直接使用，若有重名，则会隐藏基类数据，使用A::ab调用(有访问权限前提下)
```

## 函数调用顺序

```
继承中，先调用基类的构造，后调用子类的构造（析构顺序相反），在子类定义后，不会影响基类的相应构造函数和析构函数
如果基类没有无参构造，则需要在子类构造函数的初始化参数列表中调用基类的构造。
子类默认先调用基类的拷贝构造，后调用子类的拷贝构造(赋值运算符)自定义后将不再调用基类的
子类自定义拷贝构造时：
class  B:public A{
B(const  B&b):A(b){.............}
调用基类的拷贝构造
剩余内容（b中特有内容）的拷贝
};
构造函数调用顺序：
虚基类构造--->普通基类构造---->子类中的子类---->子类
```

## 多重继承

```
class  B:public A1,public A2{..........};
class  B:public A1,A2{..........}; //A2前不加public表示private继承
基类有重名时，在子类定义此名，使基类的隐藏
```

## 钻石继承

```
一个基类有多个子类，而这多个子类又是另一个类的基类
class A{public:int val;};

class B:public A{};
class C:public A{};

class D:public B,public C{};

访问D对象的val时，无法确定是B中的val还是C中的val，需要类名作用域：
D d;
int x = d.B::val;



子类通过不同的基类访问到最高层的类时，会有歧义
为了消除歧义，引入虚继承，这样最高层代码只有一份，不会产生复制，最下层可直接访问到最上层
class A{public:int val;};

class B:virtual public A{};
class C:virtual public A{};

class D:public B,public C{};

使用时：
D d;
int x = d.val;
```
