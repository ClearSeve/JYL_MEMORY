# 类结构

``` 基本函数
class A{......
   public: (//如果定义构造函数，则不能省略)

   //构造函数重载:
   A(){......}
   A(int  x， int  y)：a(3),b(x),y(y)初始化参数{.....}
   A(int  x=1){....}

   //拷贝构造:
   A(const  A&a){.....}
   //稀构函数:
   ~A(){........}
}

声明和实现分开时：初始化参数列表放在实现部分，参数的默认值在声明部分指定，函数前的static修饰放在声明处，函数的const修饰在声明和实现部分都写。
构造、析构都有系统默认的，如过要自定义，会覆盖系统的。此类函数无返回值
拷贝构造内的A&a可以不写a，如果拷贝构造的操作中有需要使用a，才必须写上

编译器会自动生成缺省的拷贝构造和赋值函数，如果不想编写这两个函数，也不希望默认的被调用，则可以将这两个函数声明为私有的。
```

## 构造函数

```
构造函数在对象创建时调用一次
A  a；  创建一个栈对象，同时调用无参构造
A  a(10); 创建一个栈对象，调用有参构造（传入参数10）

A  *p=new  A();  创建一个堆对象，同时调用无参构造（无参构造时也可用 A  *p=new  A）

A(x=1)和A()在使用A()调用时会产生冲突

const变量只能在初始化时赋值（初始化参数列表中进行），初始化参数列表中写成A(),如果A是基本类型,则A的值变为0，如果A是类类型，则为无参构造（继承中用）

```


## 声明与实现

```
类的声明和定义在开发时，是需要分开的，定义写在头文件中
返回类型   类名：：函数名（参数）{........}
=============声明
#ifndef  T_H
#define  T_H
class  Date{
   Date();
   void ShowDate();
};
#endif
=============实现
#include  "t.h"
Date::Date(){..........}
void Date::ShowDate(){..................}
```

## 特性

```
在类中调用其他函数，需要在类前声明要使用的函数。
对象创建过程，分配这个对象内存
对象没有任何成员，大小是1
对象大小由数据成员决定，和函数无关（虚函数除外）
如果对象成员是class类型，调用这个对象的无参构造。基本类型不做任何操作，有初始化参数列表时，先执行初始化参数列表
不能在定义时对数据进行初始化
class  A{int a;}不能写成int a=10；
当class中无数据需初始化，有时需要用a={}或者写一个空参构造

A&  b(){..........}
A  a;   
a.b().b().b(); 返回类型是A&，所以可以让函数多次调用

explicit  A(){}   构造函数
防止A  a=10;  语句将10转成A类型

class中每个函数的第一个参数实际为类的指针
void   ab(int *)  等价于void ab(A  a,  int  x)
因此使用  a.ab(y);
在全局区定义时： void  (*p)(A,int)
```
