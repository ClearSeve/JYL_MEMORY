# 深拷贝

```
当要拷贝的对象中有指针变量时，会使用拷贝前后两个对象中的指针指向同一块堆内存，在其中一个对象释放堆内存后，另一对象中指针指向的是一块已经释放的内存，再次释放会出错，解决此问题需要使用深拷贝方式（自己定义拷贝过程）
class  A{
       int  m；
       int  *n;
A():m(10),n(new int(8)){}
A(const A&a):n(new  int){
           m=a.m;   *n=*(a.n);  
     }
~A(){
       if(n！=NULL){delete  n; n=NULL;}
      }
}；
1)构造函数为指针分配堆内存
2)拷贝构造函数为拷贝出的对象的指针分配新的堆内存，并进行其他数据的拷贝
3)自定义析构函数释放堆内存（也可以不使用if语句进行判断，因为有时候没有给类的指针成员分配内存，而是指向null，可以不用释放,delete NULL也不会出问题）
因为有了1)和3)所以才需要2)的步骤。
```
