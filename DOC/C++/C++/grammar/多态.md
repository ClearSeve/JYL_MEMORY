# 多态

基类函数必须是virtual（子类可以不加），使用基类的指针或者引用指向子类，实现基类对象调用子类的多态。

当子类调用基类的函数a()，而这个函数又调用基类和子类都有的b()时，会调用基类的b()，只有重写时，才会调用子类的b()。

## 多态的应用

```
继承是多态的基础，虚函数重写是多态的关键
基类有虚函数，基类的指针或引用指向子类的对象时，基类掉调用这个虚函数就可以有不同表现（这个虚函数在子类中可以重写）
子类重写基类虚函数时，前面可以加virtual，也可以不加
在子类定义和基类相同的函数，这种机制为名字隐藏，但如果基类函数是虚函数，则称为函数重写（overwrite）
class A{public: virtual void ab(){1}};
class B:public A{public:virtual void ab(){2}};
1)A *p=new B();
   p->ab();  结果为2
2）B  b;
    A& a  = b;

A指向B后，通过指针pA只能访问A的成员内容，但是pA通过虚函数可以访问到B的函数，这样就相当于可以对B的内容进行操作。
```

## 虚函数表

```
class中数据占内存，函数不在class内存储，不占class内存，但在函数前加virtual，就产生一个纯虚指针（指向虚函数表），该指针相当于class中数据，会占开头位置的内存
每个类只要有虚函数，则会有自己的虚函数表，如果没有重写基类的虚函数，则虚函数表中的函数地址是基类的，如果重写了虚函数，则虚函数表中的虚函数地址是自己的
调用虚函数表中的函数，需要得到虚函数表中函数的地址，虚函数表中都是虚函数的地址
多态时，基类的纯虚指针指向子类的相应虚函数表的位置
```
